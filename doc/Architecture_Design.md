# å†…è”å‡ ä½•ä½“åº“ - æ¶æ„è®¾è®¡æ–‡æ¡£

## ğŸ“ è®¾è®¡ç›®æ ‡

### æ ¸å¿ƒåŸåˆ™
1. **ç‹¬ç«‹æ€§**ï¼šæ ¸å¿ƒç®—æ³•ä¸ä¾èµ–ç‰¹å®šå›¾å½¢API
2. **å¯æ‰©å±•**ï¼šæ˜“äºæ·»åŠ æ–°çš„å‡ ä½•ä½“ç±»å‹
3. **é«˜æ€§èƒ½**ï¼šé›¶æ‹·è´è®¾è®¡ï¼Œæœ€å°åŒ–å†…å­˜åˆ†é…
4. **æ˜“ç”¨æ€§**ï¼šç®€æ´çš„APIï¼Œæ¸…æ™°çš„æ–‡æ¡£
5. **å¯æµ‹è¯•**ï¼šçº¯æ•°æ®é©±åŠ¨ï¼Œæ˜“äºå•å…ƒæµ‹è¯•

---

## ğŸ—ï¸ å±‚çº§æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Layer 4: ç”¨æˆ·æ¥å£å±‚                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ InlineGeometryâ”‚  â”‚ CreateInfo   â”‚  â”‚ Geometry     â”‚     â”‚
â”‚  â”‚   API        â”‚  â”‚   ç»“æ„ä½“      â”‚  â”‚   å¯¹è±¡       â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Layer 3: ç®—æ³•å®ç°å±‚                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚ Cube     â”‚ â”‚ Sphere   â”‚ â”‚ Cylinder â”‚ â”‚ Revolutionâ”‚      â”‚
â”‚  â”‚ ç®—æ³•     â”‚ â”‚ ç®—æ³•     â”‚ â”‚ ç®—æ³•     â”‚ â”‚ ç®—æ³•      â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚         [48 ä¸ªå‡ ä½•ä½“ç®—æ³•å®ç°]                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Layer 2: æ„å»ºå·¥å…·å±‚                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ GeometryBuilderâ”‚ â”‚IndexGeneratorâ”‚ â”‚GeometryValidatorâ”‚   â”‚
â”‚  â”‚ é¡¶ç‚¹æ•°æ®å†™å…¥  â”‚ â”‚ ç´¢å¼•ç”Ÿæˆ    â”‚ â”‚ å‚æ•°éªŒè¯      â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Layer 1: æŠ½è±¡æ¥å£å±‚                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚IGeometry     â”‚  â”‚ GeometryData â”‚  â”‚ VAB/IB       â”‚     â”‚
â”‚  â”‚Builder       â”‚  â”‚   (çº¯æ•°æ®)    â”‚  â”‚   æŠ½è±¡       â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Layer 0: åç«¯é€‚é…å±‚                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ Vulkan       â”‚  â”‚ DirectX 12   â”‚  â”‚ Metal        â”‚     â”‚
â”‚  â”‚ Adapter      â”‚  â”‚ Adapter      â”‚  â”‚ Adapter      â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“¦ æ¨¡å—åˆ’åˆ†

### æ¨¡å— 1: Coreï¼ˆæ ¸å¿ƒæ¨¡å—ï¼‰- æ— å¤–éƒ¨ä¾èµ–

**èŒè´£ï¼š**
- å®šä¹‰å‡ ä½•æ•°æ®ç»“æ„
- æä¾›å‡ ä½•ä½“ç”Ÿæˆç®—æ³•
- é¡¶ç‚¹å’Œç´¢å¼•è®¡ç®—

**æ¥å£ç¤ºä¾‹ï¼š**
```cpp
namespace hgl::inline_geometry::core
{
    // çº¯æ•°æ®ç»“æ„
    struct VertexData
    {
        std::vector<float> positions;    // xyz, xyz, ...
        std::vector<float> normals;      // xyz, xyz, ...
        std::vector<float> tangents;     // xyz, xyz, ...
        std::vector<float> texcoords;    // uv, uv, ...
    };
    
    struct GeometryData
    {
        VertexData vertices;
        std::vector<uint32_t> indices;
        std::string name;
    };
    
    // å‡ ä½•ä½“ç”Ÿæˆå‡½æ•°ï¼ˆçº¯æ•°æ®è¾“å‡ºï¼‰
    bool GenerateCube(GeometryData& output, const CubeConfig& config);
    bool GenerateSphere(GeometryData& output, const SphereConfig& config);
    // ... å…¶ä»–å‡ ä½•ä½“
}
```

**ä¾èµ–ï¼š**
- C++ æ ‡å‡†åº“
- æ•°å­¦åº“ï¼ˆVector, Matrix - å¯ä»¥æ˜¯ GLM æˆ–è‡ªå®šä¹‰ï¼‰

---

### æ¨¡å— 2: Builderï¼ˆæ„å»ºå™¨æ¨¡å—ï¼‰

**èŒè´£ï¼š**
- æä¾›é«˜çº§æ„å»ºæ¥å£
- ç®¡ç†é¡¶ç‚¹å±æ€§æ˜ å°„
- æä¾›ä¾¿åˆ©æ–¹æ³•

**æ¥å£ç¤ºä¾‹ï¼š**
```cpp
namespace hgl::inline_geometry::builder
{
    // æŠ½è±¡æ„å»ºå™¨æ¥å£
    class IGeometryBuilder
    {
    public:
        virtual void WriteVertex(float x, float y, float z) = 0;
        virtual void WriteNormal(float x, float y, float z) = 0;
        virtual void WriteTangent(float x, float y, float z) = 0;
        virtual void WriteTexCoord(float u, float v) = 0;
        virtual void WriteIndex(uint32_t index) = 0;
        
        virtual bool HasNormals() const = 0;
        virtual bool HasTangents() const = 0;
        virtual bool HasTexCoords() const = 0;
        
        virtual ~IGeometryBuilder() = default;
    };
    
    // åŸºäº GeometryData çš„å®ç°
    class DataBuilder : public IGeometryBuilder
    {
        GeometryData& data_;
    public:
        explicit DataBuilder(GeometryData& data) : data_(data) {}
        
        void WriteVertex(float x, float y, float z) override
        {
            data_.vertices.positions.push_back(x);
            data_.vertices.positions.push_back(y);
            data_.vertices.positions.push_back(z);
        }
        // ... å…¶ä»–å®ç°
    };
}
```

---

### æ¨¡å— 3: Adaptersï¼ˆé€‚é…å™¨æ¨¡å—ï¼‰

**èŒè´£ï¼š**
- è¿æ¥æ ¸å¿ƒæ¨¡å—ä¸å…·ä½“å›¾å½¢API
- å¤„ç†APIç‰¹å®šçš„èµ„æºç®¡ç†
- æä¾›å‘åå…¼å®¹æ¥å£

**Vulkan é€‚é…å™¨ç¤ºä¾‹ï¼š**
```cpp
namespace hgl::inline_geometry::adapters::vulkan
{
    class VulkanGeometryAdapter
    {
        VulkanDevice* device_;
        GeometryCreater* creater_;
        
    public:
        VulkanGeometryAdapter(VulkanDevice* device);
        
        // ä» GeometryData åˆ›å»º Vulkan Geometry
        Geometry* CreateFromData(const core::GeometryData& data);
        
        // å…¼å®¹æ—§æ¥å£
        Geometry* CreateCube(const CubeCreateInfo* info)
        {
            core::GeometryData data;
            core::CubeConfig config = ConvertConfig(info);
            
            if(!core::GenerateCube(data, config))
                return nullptr;
            
            return CreateFromData(data);
        }
    };
}
```

---

## ğŸ”„ æ•°æ®æµ

### æ–¹å¼ 1: çº¯æ•°æ®æµï¼ˆæ¨èç”¨äºæµ‹è¯•å’Œå¯¼å‡ºï¼‰

```
ç”¨æˆ·ä»£ç 
    â†“
é…ç½®ç»“æ„ä½“ (CubeConfig)
    â†“
æ ¸å¿ƒç®—æ³• (GenerateCube)
    â†“
å‡ ä½•æ•°æ® (GeometryData)
    â†“
å¯¼å‡º/åºåˆ—åŒ– (OBJ, FBX, etc.)
```

**ç¤ºä¾‹ï¼š**
```cpp
// ç”Ÿæˆç«‹æ–¹ä½“æ•°æ®
core::GeometryData cube_data;
core::CubeConfig config;
config.size = 1.0f;
config.generate_normals = true;

core::GenerateCube(cube_data, config);

// å¯¼å‡ºä¸º OBJ
exporter::SaveAsOBJ(cube_data, "cube.obj");
```

---

### æ–¹å¼ 2: ç›´æ¥æ¸²æŸ“æµï¼ˆç”¨äºå®æ—¶æ¸²æŸ“ï¼‰

```
ç”¨æˆ·ä»£ç 
    â†“
CreateInfo ç»“æ„ä½“
    â†“
é€‚é…å™¨ (VulkanAdapter)
    â†“
    â”œâ”€â†’ æ ¸å¿ƒç®—æ³• (ç”Ÿæˆæ•°æ®)
    â””â”€â†’ èµ„æºç®¡ç† (åˆ›å»º GPU ç¼“å†²)
    â†“
Geometry å¯¹è±¡ (å¯ç›´æ¥æ¸²æŸ“)
```

**ç¤ºä¾‹ï¼š**
```cpp
// Vulkan æ¸²æŸ“è·¯å¾„
VulkanGeometryAdapter adapter(device);

CubeCreateInfo info;
info.normal = true;
info.tangent = true;

Geometry* cube = adapter.CreateCube(&info);
// cube å¯ä»¥ç›´æ¥ç”¨äºæ¸²æŸ“
```

---

## ğŸ§© å…³é”®è®¾è®¡å†³ç­–

### å†³ç­– 1: åˆ†ç¦»æ•°æ®å’Œèµ„æº

**é—®é¢˜ï¼š** å½“å‰å®ç°æ•°æ®ç”Ÿæˆå’ŒGPUèµ„æºåˆ›å»ºè€¦åˆåœ¨ä¸€èµ·

**è§£å†³æ–¹æ¡ˆï¼š**
```cpp
// åˆ†ç¦»å‰ï¼ˆæ—§ï¼‰
Geometry* CreateCube(GeometryCreater* pc, ...);  // ç›´æ¥åˆ›å»ºGPUèµ„æº

// åˆ†ç¦»åï¼ˆæ–°ï¼‰
// æ­¥éª¤1: ç”Ÿæˆæ•°æ®
core::GeometryData data;
core::GenerateCube(data, config);

// æ­¥éª¤2: åˆ›å»ºGPUèµ„æºï¼ˆå¯é€‰ï¼‰
Geometry* gpu_geom = adapter.CreateFromData(data);
```

**ä¼˜åŠ¿ï¼š**
- æ•°æ®å¯ä»¥åœ¨CPUç«¯æµ‹è¯•
- æ•°æ®å¯ä»¥åºåˆ—åŒ–ä¿å­˜
- åŒä¸€ä»½æ•°æ®å¯ç”¨äºä¸åŒAPI
- ä¾¿äºå•å…ƒæµ‹è¯•

---

### å†³ç­– 2: ä½¿ç”¨æ¥å£è€Œéæ¨¡æ¿

**é—®é¢˜ï¼š** GeometryBuilder å½“å‰æ˜¯å…·ä½“ç±»ï¼Œéš¾ä»¥æ›¿æ¢

**è§£å†³æ–¹æ¡ˆï¼š**
```cpp
// å®šä¹‰æ¥å£
class IGeometryBuilder { /* ... */ };

// ä¸åŒå®ç°
class DataBuilder : public IGeometryBuilder { /* å†™å…¥ vector */ };
class VulkanBuilder : public IGeometryBuilder { /* ç›´æ¥å†™å…¥æ˜ å°„å†…å­˜ */ };
class TestBuilder : public IGeometryBuilder { /* ç”¨äºæµ‹è¯• */ };

// ç®—æ³•ä½¿ç”¨æ¥å£
void GenerateCube(IGeometryBuilder* builder, const CubeConfig& config)
{
    builder->WriteVertex(0.5f, 0.5f, 0.5f);
    // ...
}
```

**ä¼˜åŠ¿ï¼š**
- æ˜“äºæµ‹è¯•ï¼ˆMock Builderï¼‰
- æ”¯æŒä¸åŒåç«¯
- è¿è¡Œæ—¶å¤šæ€

---

### å†³ç­– 3: é…ç½®ä¸æ•°æ®åˆ†ç¦»

**é—®é¢˜ï¼š** å½“å‰ CreateInfo ç»“æ„ä½“åŒ…å«è¿‡å¤šçŠ¶æ€

**è§£å†³æ–¹æ¡ˆï¼š**
```cpp
// å‡ ä½•é…ç½®ï¼ˆè¾“å…¥ï¼‰
struct CubeConfig
{
    float size = 1.0f;
    bool generate_normals = true;
    bool generate_tangents = true;
    bool generate_uvs = true;
};

// å‡ ä½•æ•°æ®ï¼ˆè¾“å‡ºï¼‰
struct GeometryData
{
    VertexData vertices;
    std::vector<uint32_t> indices;
};

// æ¸…æ™°çš„è¾“å…¥è¾“å‡º
bool GenerateCube(GeometryData& output, const CubeConfig& input);
```

---

## ğŸ”Œ æ‰©å±•ç‚¹

### æ‰©å±•ç‚¹ 1: æ·»åŠ æ–°å‡ ä½•ä½“

```cpp
// 1. å®šä¹‰é…ç½®
struct MyGeometryConfig
{
    float parameter1;
    uint32_t parameter2;
    // ...
};

// 2. å®ç°ç®—æ³•
bool GenerateMyGeometry(GeometryData& output, const MyGeometryConfig& config)
{
    // è®¡ç®—é¡¶ç‚¹å’Œç´¢å¼•
    // å†™å…¥ output
    return true;
}

// 3. åœ¨é€‚é…å™¨ä¸­æ·»åŠ ä¾¿åˆ©å‡½æ•°ï¼ˆå¯é€‰ï¼‰
Geometry* VulkanAdapter::CreateMyGeometry(const MyGeometryConfig& config)
{
    GeometryData data;
    if(!GenerateMyGeometry(data, config))
        return nullptr;
    return CreateFromData(data);
}
```

---

### æ‰©å±•ç‚¹ 2: æ”¯æŒæ–°å›¾å½¢API

```cpp
// 1. å®ç° IGeometryBuilder æ¥å£
class DirectX12Builder : public IGeometryBuilder
{
    ID3D12Resource* vertex_buffer_;
    void* mapped_data_;
    
public:
    void WriteVertex(float x, float y, float z) override
    {
        // å†™å…¥ D3D12 ç¼“å†²
    }
    // ...
};

// 2. åˆ›å»ºé€‚é…å™¨
class DirectX12Adapter
{
public:
    Geometry* CreateFromData(const GeometryData& data)
    {
        // åˆ›å»º D3D12 èµ„æº
        // ä¸Šä¼ æ•°æ®
        // è¿”å› Geometry å¯¹è±¡
    }
};
```

---

### æ‰©å±•ç‚¹ 3: è‡ªå®šä¹‰é¡¶ç‚¹æ ¼å¼

```cpp
// 1. å®šä¹‰é¡¶ç‚¹ç»“æ„
struct MyVertex
{
    Vector3f position;
    Vector3f normal;
    Vector2f uv;
    Color4f color;
};

// 2. å®ç°è½¬æ¢
std::vector<MyVertex> ConvertToCustomFormat(const GeometryData& data)
{
    std::vector<MyVertex> result;
    const size_t count = data.vertices.positions.size() / 3;
    
    for(size_t i = 0; i < count; ++i)
    {
        MyVertex v;
        v.position.x = data.vertices.positions[i * 3 + 0];
        v.position.y = data.vertices.positions[i * 3 + 1];
        v.position.z = data.vertices.positions[i * 3 + 2];
        // ... å¡«å……å…¶ä»–å­—æ®µ
        result.push_back(v);
    }
    
    return result;
}
```

---

## ğŸ“Š æ€§èƒ½è€ƒè™‘

### 1. é›¶æ‹·è´è®¾è®¡

**å½“å‰å®ç°ï¼ˆä¼˜åŒ–ï¼‰ï¼š**
```cpp
// ç›´æ¥æ˜ å°„ GPU å†…å­˜ï¼Œæ— æ‹·è´
VABMapFloat vertex_map(pc->GetVABMap(VAN::Position), VF_V3F);
float* vp = vertex_map;

// ç›´æ¥å†™å…¥
*vp++ = x; *vp++ = y; *vp++ = z;
```

**æœªæ¥ä¼˜åŒ–ï¼š**
```cpp
// é¢„åˆ†é…å®¹é‡ï¼Œå‡å°‘ reallocation
data.vertices.positions.reserve(expected_vertex_count * 3);

// ä½¿ç”¨ emplace_back é¿å…ä¸´æ—¶å¯¹è±¡
data.vertices.positions.emplace_back(x);
```

---

### 2. å†…å­˜å¸ƒå±€ä¼˜åŒ–

**é€‰é¡¹ A: SoA (Structure of Arrays) - å½“å‰æ–¹æ¡ˆ**
```cpp
struct VertexData
{
    std::vector<float> positions;  // [x,y,z, x,y,z, ...]
    std::vector<float> normals;    // [x,y,z, x,y,z, ...]
    std::vector<float> texcoords;  // [u,v, u,v, ...]
};
```
- âœ… çµæ´»ï¼ˆå¯é€‰å±æ€§ï¼‰
- âœ… GPUå‹å¥½ï¼ˆåˆ†ç¦»ç¼“å†²ï¼‰
- âš ï¸ ç¼“å­˜ä¸å‹å¥½

**é€‰é¡¹ B: AoS (Array of Structures)**
```cpp
struct Vertex
{
    float position[3];
    float normal[3];
    float texcoord[2];
};

std::vector<Vertex> vertices;
```
- âœ… ç¼“å­˜å‹å¥½
- âœ… æ˜“äºç†è§£
- âš ï¸ ä¸çµæ´»ï¼ˆå›ºå®šæ ¼å¼ï¼‰

**æ¨èï¼š** ä¿æŒ SoAï¼Œæä¾›è½¬æ¢å‡½æ•°

---

### 3. ç´¢å¼•ç±»å‹ä¼˜åŒ–

```cpp
// è‡ªåŠ¨é€‰æ‹©ç´¢å¼•ç±»å‹
IndexType DetermineIndexType(uint32_t vertex_count)
{
    if(vertex_count <= 65535)
        return IndexType::U16;  // 2å­—èŠ‚ï¼ŒèŠ‚çœå†…å­˜
    else
        return IndexType::U32;  // 4å­—èŠ‚
}
```

---

## ğŸ§ª æµ‹è¯•ç­–ç•¥

### å•å…ƒæµ‹è¯•ï¼ˆCore æ¨¡å—ï¼‰

```cpp
TEST_CASE("Cube generation", "[geometry][cube]")
{
    core::GeometryData data;
    core::CubeConfig config;
    
    REQUIRE(core::GenerateCube(data, config));
    
    // éªŒè¯é¡¶ç‚¹æ•°
    REQUIRE(data.vertices.positions.size() == 24 * 3);
    
    // éªŒè¯ç´¢å¼•æ•°
    REQUIRE(data.indices.size() == 36);
    
    // éªŒè¯é¡¶ç‚¹èŒƒå›´
    for(size_t i = 0; i < data.vertices.positions.size(); ++i)
    {
        REQUIRE(data.vertices.positions[i] >= -0.5f);
        REQUIRE(data.vertices.positions[i] <= 0.5f);
    }
    
    // éªŒè¯æ³•çº¿å½’ä¸€åŒ–
    // ...
}
```

---

### é›†æˆæµ‹è¯•ï¼ˆAdapter æ¨¡å—ï¼‰

```cpp
TEST_CASE("Vulkan adapter", "[adapter][vulkan]")
{
    VulkanTestContext ctx;  // æµ‹è¯•ç”¨ Vulkan ä¸Šä¸‹æ–‡
    
    VulkanAdapter adapter(ctx.device);
    CubeCreateInfo info;
    
    Geometry* geom = adapter.CreateCube(&info);
    
    REQUIRE(geom != nullptr);
    REQUIRE(geom->GetVertexCount() == 24);
    REQUIRE(geom->GetIndexCount() == 36);
    
    // æ¸…ç†
    delete geom;
}
```

---

### æ¸²æŸ“æµ‹è¯•

```cpp
// æ¸²æŸ“åˆ°çº¹ç†ï¼Œå¯¹æ¯”åƒç´ 
TEST_CASE("Cube rendering", "[render][cube]")
{
    // 1. æ¸²æŸ“å‚è€ƒå›¾åƒ
    Image reference = RenderReference("cube_baseline.png");
    
    // 2. æ¸²æŸ“å½“å‰å®ç°
    Geometry* cube = CreateCube(...);
    Image result = RenderGeometry(cube);
    
    // 3. å¯¹æ¯”å›¾åƒ
    float diff = CompareImages(reference, result);
    REQUIRE(diff < 0.01f);  // å…è®¸å°è¯¯å·®
}
```

---

## ğŸ“š ä½¿ç”¨ç¤ºä¾‹

### ç¤ºä¾‹ 1: åŸºç¡€ä½¿ç”¨ï¼ˆçº¯æ•°æ®ï¼‰

```cpp
#include <hgl_inline_geometry/core.h>
#include <hgl_inline_geometry/export.h>

int main()
{
    // ç”Ÿæˆç«‹æ–¹ä½“æ•°æ®
    hgl::inline_geometry::core::GeometryData cube;
    hgl::inline_geometry::core::CubeConfig config;
    
    config.size = 2.0f;
    config.generate_normals = true;
    
    if(!hgl::inline_geometry::core::GenerateCube(cube, config))
    {
        std::cerr << "Failed to generate cube" << std::endl;
        return 1;
    }
    
    // å¯¼å‡ºä¸º OBJ
    hgl::inline_geometry::export_obj(cube, "my_cube.obj");
    
    return 0;
}
```

---

### ç¤ºä¾‹ 2: Vulkan é›†æˆ

```cpp
#include <hgl/graph/geo/InlineGeometry.h>

void CreateScene(VulkanDevice* device)
{
    GeometryCreater creater(device, vertex_input_layout);
    
    // åˆ›å»ºç«‹æ–¹ä½“
    CubeCreateInfo cube_info;
    Geometry* cube = CreateCube(&creater, &cube_info);
    
    // åˆ›å»ºçƒä½“
    Geometry* sphere = CreateSphere(&creater, 32);
    
    // æ·»åŠ åˆ°åœºæ™¯...
}
```

---

### ç¤ºä¾‹ 3: æ‰¹é‡ç”Ÿæˆ

```cpp
// æ‰¹é‡ç”Ÿæˆå¤šä¸ªå‡ ä½•ä½“ï¼ˆå…±äº«æ•°æ®ï¼‰
std::vector<core::GeometryData> geometries;

for(int i = 0; i < 100; ++i)
{
    core::GeometryData data;
    core::SphereConfig config;
    config.radius = 0.5f + i * 0.01f;
    config.slices = 16;
    
    core::GenerateSphere(data, config);
    geometries.push_back(std::move(data));
}

// ä¸€æ¬¡æ€§ä¸Šä¼ åˆ° GPU
adapter.BatchUpload(geometries);
```

---

## ğŸ—ºï¸ è¿ç§»è·¯å¾„

### é˜¶æ®µ 1: å†…éƒ¨é‡æ„ï¼ˆå‘åå…¼å®¹ï¼‰
```cpp
// ç”¨æˆ·ä»£ç ä¸å˜
Geometry* cube = CreateCube(pc, &info);

// å†…éƒ¨å®ç°æ”¹ä¸ºï¼š
Geometry* CreateCube(GeometryCreater* pc, const CubeCreateInfo* info)
{
    // 1. ç”Ÿæˆæ•°æ®
    core::GeometryData data;
    core::CubeConfig config = ConvertConfig(info);
    core::GenerateCube(data, config);
    
    // 2. ä¸Šä¼ åˆ° GPU
    return UploadToGPU(pc, data);
}
```

---

### é˜¶æ®µ 2: æä¾›æ–°API
```cpp
// æ–° APIï¼ˆæ¨èï¼‰
core::GeometryData data;
core::GenerateCube(data, config);

// æ—§ APIï¼ˆå…¼å®¹ï¼‰
Geometry* cube = CreateCube(pc, &info);  // å†…éƒ¨è°ƒç”¨æ–° API
```

---

### é˜¶æ®µ 3: å¼ƒç”¨æ—§API
```cpp
// æ ‡è®°ä¸ºåºŸå¼ƒ
[[deprecated("Use core::GenerateCube instead")]]
Geometry* CreateCube(GeometryCreater* pc, const CubeCreateInfo* info);
```

---

### é˜¶æ®µ 4: ç§»é™¤æ—§APIï¼ˆä¸»ç‰ˆæœ¬å‡çº§ï¼‰
```cpp
// ä»…ä¿ç•™æ–° API
namespace hgl::inline_geometry::core
{
    bool GenerateCube(GeometryData& output, const CubeConfig& config);
}
```

---

## ğŸ“– æ€»ç»“

è¿™ä¸ªæ¶æ„è®¾è®¡å®ç°äº†ï¼š

âœ… **ç‹¬ç«‹æ€§** - æ ¸å¿ƒç®—æ³•ä¸ä¾èµ–å›¾å½¢API  
âœ… **çµæ´»æ€§** - æ”¯æŒå¤šç§åç«¯å’Œè‡ªå®šä¹‰æ ¼å¼  
âœ… **å¯æµ‹è¯•æ€§** - çº¯æ•°æ®é©±åŠ¨ï¼Œæ˜“äºå•å…ƒæµ‹è¯•  
âœ… **é«˜æ€§èƒ½** - é›¶æ‹·è´è®¾è®¡ï¼Œå†…å­˜é«˜æ•ˆ  
âœ… **å‘åå…¼å®¹** - ä¿æŒç°æœ‰æ¥å£ï¼Œæ¸è¿›è¿ç§»  
âœ… **æ˜“æ‰©å±•** - æ¸…æ™°çš„æ‰©å±•ç‚¹ï¼Œæ˜“äºæ·»åŠ æ–°åŠŸèƒ½  

**ä¸‹ä¸€æ­¥ï¼š** å‚è€ƒ [Quick_Start_Guide.md](Quick_Start_Guide.md) å¼€å§‹å®æ–½ï¼

---

*æ¶æ„æ–‡æ¡£ç‰ˆæœ¬ï¼šv1.0*  
*æœ€åæ›´æ–°ï¼š2026-01-02*
